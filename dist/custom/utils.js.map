{
  "version": 3,
  "sources": ["../../src/custom/utils.js"],
  "sourcesContent": ["import { WHITE_KEYS_MIDI_VALUES, EXERCISE_TYPES, NOTE_CONVERSION_MAP, MIDI_NOTE_NAMES, INVERSIONS, TRIADS } from './constants.js';\r\n\r\nexport const hallo = 'Hallo';\r\n\r\nexport const randomIntBetween = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\n\r\nexport const sortLowToHigh = array => {\r\n  return array.sort((a, b) => a - b);\r\n};\r\n\r\nexport const randomArrayElem = array => {\r\n  return array[randomIntBetween(0, array.length - 1)];\r\n};\r\n\r\nexport const getMidiValueFromWhiteKeyIndex = index => WHITE_KEYS_MIDI_VALUES[index];\r\nexport const getMidiValueFromNoteName = noteName => MIDI_NOTE_NAMES.indexOf(noteName);\r\nexport const getMidiValueFromMidiNoteName = midiNoteName => MIDI_NOTE_NAMES.indexOf(midiNoteName);\r\nexport const getNoteNameFromMidiValue = midiValue => MIDI_NOTE_NAMES[midiValue];\r\n\r\nexport const isIntervalExercise = test => test.exerciseType === EXERCISE_TYPES.interval;\r\nexport const isChordExercise = test => test.exerciseType === EXERCISE_TYPES.chord;\r\nexport const isNoteSequenceExercise = test => test.exerciseType === EXERCISE_TYPES.noteSequence;\r\nexport const isRandomNoteSequenceExercise = test => test.exerciseType === EXERCISE_TYPES.noteSequence && !test.isCustomNoteSequence;\r\nexport const isCustomNoteSequenceExercise = test => test.exerciseType === EXERCISE_TYPES.noteSequence && test.isCustomNoteSequence;\r\nexport const isIntervalOrChordExercise = test => isIntervalExercise(test) || isChordExercise(test);\r\nexport const allowsLargeIntervals = test => test[`${test.exerciseType}AllowsLargeIntervals`];\r\n\r\nexport const getBorderKeyRangeMidiValues = noteRange => [getMidiValueFromWhiteKeyIndex(noteRange.first), getMidiValueFromWhiteKeyIndex(noteRange.last)];\r\n\r\nexport const isAnswerComplete = params => {\r\n  const { test, answerMidiValueSequence, midiValueSequence, answerAbcNoteNameSequenceRef, abcNoteNameSequence } = params;\r\n  if (isNoteSequenceExercise(test)) {\r\n    return answerAbcNoteNameSequenceRef.current.length >= abcNoteNameSequence.length - 1;\r\n  }\r\n  return answerMidiValueSequence.length >= midiValueSequence.length - 1;\r\n};\r\n\r\nexport function filterAbcString(string) {\r\n  let newString = string;\r\n  const validChars = ['^', '_', 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C', 'D', 'E', 'F', 'G', 'A', 'B', '\\'', ','];\r\n\r\n  const charsToDelete = [];\r\n  for (let i = 0; i < newString.length; i += 1) {\r\n    if (!validChars.includes(newString[i])) {\r\n      !charsToDelete.includes(newString[i]) && charsToDelete.push(newString[i]);\r\n    }\r\n  }\r\n  charsToDelete.forEach(elem => {\r\n    newString = newString.replaceAll(elem, '');\r\n  });\r\n\r\n  return newString;\r\n}\r\n\r\nexport function analyseABC(string) {\r\n  if (string.length === 0) {\r\n    return { abcNoteNameSequence: null,\r\n      midiNoteNameSequence: null,\r\n      midiValueSequence: null,\r\n      filteredAbc: null };\r\n  }\r\n\r\n  const noteNameLetters = ['c', 'd', 'e', 'f', 'g', 'a', 'b', 'z', 'x', 'C', 'D', 'E', 'F', 'G', 'A', 'B'];\r\n  const noteStartChars = ['^', '_', 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'z', 'x', 'C', 'D', 'E', 'F', 'G', 'A', 'B'];\r\n  const abcNoteNameSequence = [];\r\n  const midiNoteNameSequence = [];\r\n  const midiValueSequence = [];\r\n  let newString = filterAbcString(string);\r\n  const filteredAbc = newString;\r\n\r\n  while (newString.length > 0 || typeof newString !== 'undefined') {\r\n\r\n    let index = 0;\r\n    let noteNameLetterIndex;\r\n    let isNoteNameLetterFound = false;\r\n\r\n    while (!noteStartChars.includes(newString[index])) {\r\n      index += 1;\r\n    }\r\n\r\n    if (noteNameLetters.includes(newString[index])) {\r\n      isNoteNameLetterFound = true;\r\n      noteNameLetterIndex = index;\r\n    }\r\n\r\n    const noteStartIndex = index;\r\n    let nextNoteStartIndex;\r\n    index += 1;\r\n\r\n    while (!isNoteNameLetterFound || typeof nextNoteStartIndex === 'undefined') {\r\n      if (typeof newString[index] === 'undefined') {\r\n        break;\r\n      }\r\n      if (!isNoteNameLetterFound && noteNameLetters.includes(newString[index].toLowerCase())) {\r\n        isNoteNameLetterFound = true;\r\n        noteNameLetterIndex = index;\r\n      }\r\n      if (isNoteNameLetterFound && noteNameLetterIndex !== index && noteStartChars.includes(newString[index])) {\r\n        nextNoteStartIndex = index;\r\n      }\r\n      index += 1;\r\n    }\r\n\r\n    // Checks if only last note is remaining.\r\n    if (typeof nextNoteStartIndex === 'undefined') {\r\n      let lastNote = true;\r\n      for (let i = index; i < newString.length; i += 1) {\r\n        if (noteNameLetters.includes(newString[i])) {\r\n          lastNote = false;\r\n        }\r\n      }\r\n      if (lastNote) {\r\n        const abcNoteName = newString.substring(0);\r\n        const midiNoteName = NOTE_CONVERSION_MAP.get(abcNoteName);\r\n        const midiValue = getMidiValueFromMidiNoteName(midiNoteName);\r\n        abcNoteNameSequence.push(abcNoteName);\r\n        midiNoteNameSequence.push(midiNoteName);\r\n        midiValueSequence.push(midiValue);\r\n        return { abcNoteNameSequence, midiNoteNameSequence, midiValueSequence, filteredAbc };\r\n      }\r\n    }\r\n\r\n    const abcNoteName = newString.substring(noteStartIndex, nextNoteStartIndex);\r\n    const midiNoteName = NOTE_CONVERSION_MAP.get(abcNoteName);\r\n    const midiValue = getMidiValueFromMidiNoteName(midiNoteName);\r\n    abcNoteNameSequence.push(abcNoteName);\r\n    midiNoteNameSequence.push(midiNoteName);\r\n    midiValueSequence.push(midiValue);\r\n\r\n    newString = newString.substring(nextNoteStartIndex);\r\n\r\n    if (typeof newString[0] === 'undefined') {\r\n      return { abcNoteNameSequence, midiNoteNameSequence, midiValueSequence, filteredAbc };\r\n    }\r\n  }\r\n  return { abcNoteNameSequence, midiNoteNameSequence, midiValueSequence, filteredAbc };\r\n}\r\n\r\nexport const playNotesSimultaneously = async (sampler, midiNoteNameSequence, noteDurationRef, isExercisePlayingRef) => {\r\n  sampler.triggerAttackRelease(midiNoteNameSequence, noteDurationRef.current / 1000);\r\n  await new Promise(res => {\r\n    setTimeout(() => {\r\n      res();\r\n      isExercisePlayingRef.current = false;\r\n    }, noteDurationRef.current);\r\n  });\r\n};\r\n\r\nexport const playNotesSuccessively = async (sampler, midiNoteNameSequence, noteDurationRef, isExercisePlayingRef, playExerciseStartIndex) => {\r\n  for (let i = playExerciseStartIndex; i < midiNoteNameSequence.length; i += 1) {\r\n    // Check if stop button has been clicked\r\n    if (!isExercisePlayingRef.current) {\r\n      return;\r\n    }\r\n    sampler.triggerAttackRelease(midiNoteNameSequence[i], noteDurationRef.current / 1000);\r\n    // eslint-disable-next-line no-await-in-loop\r\n    await new Promise(res => {\r\n      setTimeout(() => {\r\n        res();\r\n      }, noteDurationRef.current);\r\n    });\r\n  }\r\n  isExercisePlayingRef.current = false;\r\n};\r\n\r\nexport const isKeyOutOfRange = (keyRange, midiValue) => {\r\n  if (midiValue < WHITE_KEYS_MIDI_VALUES[keyRange.first] || midiValue > WHITE_KEYS_MIDI_VALUES[keyRange.last]) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const usesWhiteKeysOnly = test => {\r\n  return test.exerciseType === EXERCISE_TYPES.noteSequence\r\n    && !test.isCustomNoteSequence\r\n    && test.whiteKeysOnly;\r\n};\r\n\r\nexport const isInRange = (keyRange, midiValue) => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  return midiValue >= firstKeyRangeMidiValue && midiValue <= lastKeyRangeMidiValue;\r\n};\r\n\r\nexport const isWhiteKey = midiValue => WHITE_KEYS_MIDI_VALUES.indexOf(midiValue) !== -1;\r\n\r\nexport const getIndicationMidiValueAndFirstVector = (test, keyRange, intervalVectors) => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  let indicationMidiValue = randomIntBetween(firstKeyRangeMidiValue, lastKeyRangeMidiValue);\r\n  const firstVector = randomArrayElem(intervalVectors);\r\n  if (usesWhiteKeysOnly(test) && !isWhiteKey(indicationMidiValue)) {\r\n    indicationMidiValue = indicationMidiValue + 1 <= lastKeyRangeMidiValue ? indicationMidiValue + 1 : indicationMidiValue - 1;\r\n    if ((!isWhiteKey(indicationMidiValue + firstVector) || !isInRange(keyRange, indicationMidiValue + firstVector)) && [5, 7].includes(firstVector)) {\r\n      for (let i = firstKeyRangeMidiValue; i <= lastKeyRangeMidiValue; i += 1) {\r\n        indicationMidiValue = i;\r\n        if (isWhiteKey(indicationMidiValue) && isInRange(keyRange, indicationMidiValue + firstVector) && isWhiteKey(indicationMidiValue + firstVector)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return [indicationMidiValue, firstVector];\r\n};\r\n\r\nexport const getIndicationMidiValue = keyRange => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  const indicationMidiValue = randomIntBetween(firstKeyRangeMidiValue, lastKeyRangeMidiValue);\r\n  return indicationMidiValue;\r\n};\r\n\r\nexport const getWhiteKey = (midiValue, vector) => {\r\n  return vector < 0 ? midiValue + vector - 1 : midiValue + vector + 1;\r\n};\r\n\r\nexport const getNextNoteSequenceVectorAndMidiValue = (test, currentMidiValue, keyRange, intervalVectors, firstVector, i) => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  let newVector = i === 0 ? firstVector : randomArrayElem(intervalVectors) * randomArrayElem([-1, 1]);\r\n  let nextMidiValue = currentMidiValue + newVector;\r\n\r\n  while (!isInRange(keyRange, nextMidiValue) || (test.whiteKeysOnly && !isWhiteKey(nextMidiValue))) {\r\n    newVector = randomArrayElem(intervalVectors) * randomArrayElem([-1, 1]);\r\n    nextMidiValue = currentMidiValue + newVector;\r\n  }\r\n\r\n  if (allowsLargeIntervals(test)) {\r\n    const possibleNextMidiValues = [];\r\n    if (newVector < 0) {\r\n      while (currentMidiValue + newVector > firstKeyRangeMidiValue) {\r\n        possibleNextMidiValues.push(currentMidiValue + newVector);\r\n        newVector -= 12;\r\n      }\r\n    } else if (newVector > 0) {\r\n      while (currentMidiValue + newVector < lastKeyRangeMidiValue) {\r\n        possibleNextMidiValues.push(currentMidiValue + newVector);\r\n        newVector += 12;\r\n      }\r\n    }\r\n    if (possibleNextMidiValues.length > 0) {\r\n      nextMidiValue = randomArrayElem(possibleNextMidiValues);\r\n    }\r\n  }\r\n\r\n  return nextMidiValue;\r\n};\r\n\r\nexport const getNextChordMidiValue = (test, bassNoteMidiValue, vector, keyRange) => {\r\n  const lastKeyRangeMidiValue = WHITE_KEYS_MIDI_VALUES[keyRange.last];\r\n  let currentMidiValue = bassNoteMidiValue;\r\n  let nextMidiValue = bassNoteMidiValue + vector;\r\n\r\n  if (allowsLargeIntervals(test)) {\r\n    const possibleMidiValues = [];\r\n\r\n    while (currentMidiValue + vector < lastKeyRangeMidiValue) {\r\n      possibleMidiValues.push(currentMidiValue + vector);\r\n      currentMidiValue += 12;\r\n    }\r\n    nextMidiValue = randomArrayElem(possibleMidiValues);\r\n  }\r\n\r\n  return nextMidiValue;\r\n};\r\n\r\nexport const getVectorDirections = test => {\r\n  const directionCheckboxStates = test.directionCheckboxStates;\r\n  if (directionCheckboxStates.up && !directionCheckboxStates.down) {\r\n    return [true, false];\r\n  }\r\n  if (!directionCheckboxStates.up && directionCheckboxStates.down) {\r\n    return [false, true];\r\n  }\r\n  return [false, false];\r\n};\r\n\r\nexport const getVector = intervalVectors => randomArrayElem(intervalVectors);\r\n\r\nexport const getVectorWithDirection = (vector, useVectorUpOnly, useVectorDownOnly) => {\r\n  let vectorWithDirection = vector;\r\n  if (useVectorDownOnly) {\r\n    vectorWithDirection *= -1;\r\n  }\r\n  if (!useVectorUpOnly && !useVectorDownOnly) {\r\n    vectorWithDirection *= randomArrayElem([-1, 1]);\r\n  }\r\n  return vectorWithDirection;\r\n};\r\n\r\nexport const adjustIndicationMidiValue = (keyRange, vectorWithDirection) => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  let indicationMidiValue = Math.floor((firstKeyRangeMidiValue + lastKeyRangeMidiValue) / 2);\r\n  let nextMidiValue = indicationMidiValue + vectorWithDirection;\r\n  if (vectorWithDirection < 0) {\r\n    for (let i = indicationMidiValue; i <= lastKeyRangeMidiValue; i += 1) {\r\n      if (isInRange(keyRange, nextMidiValue)) {\r\n        break;\r\n      }\r\n      indicationMidiValue += 1;\r\n      nextMidiValue += 1;\r\n    }\r\n  }\r\n  if (vectorWithDirection > 0) {\r\n    for (let i = indicationMidiValue; i >= firstKeyRangeMidiValue; i -= 1) {\r\n      if (isInRange(keyRange, nextMidiValue)) {\r\n        break;\r\n      }\r\n      indicationMidiValue -= 1;\r\n      nextMidiValue -= 1;\r\n    }\r\n  }\r\n  return indicationMidiValue;\r\n};\r\n\r\nexport const getPossibleNextMidiValues = (indicationMidiValue, vectorWithDirection, keyRange) => {\r\n  const [firstKeyRangeMidiValue, lastKeyRangeMidiValue] = getBorderKeyRangeMidiValues(keyRange);\r\n  const arr = [];\r\n  let modifiedVector = vectorWithDirection;\r\n  if (modifiedVector < 0) {\r\n    while ((indicationMidiValue + modifiedVector) > firstKeyRangeMidiValue) {\r\n      arr.push(indicationMidiValue + modifiedVector);\r\n      modifiedVector -= 12;\r\n    }\r\n  }\r\n  if (modifiedVector > 0) {\r\n    while ((indicationMidiValue + modifiedVector) < lastKeyRangeMidiValue) {\r\n      arr.push(indicationMidiValue + modifiedVector);\r\n      modifiedVector += 12;\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\nexport const widenKeyRangeIfNeeded = params => {\r\n  const { noteRange, midiNoteNameSequence, test, intervalVectors, chordVector } = params;\r\n  let firstKeyRangeMidiValue = getMidiValueFromWhiteKeyIndex(noteRange.first);\r\n  let lastKeyRangeMidiValue = getMidiValueFromWhiteKeyIndex(noteRange.last);\r\n  const vectors = isChordExercise(test) ? chordVector : intervalVectors;\r\n\r\n  if (isCustomNoteSequenceExercise(test)) {\r\n    for (let i = 0; i < midiNoteNameSequence.length; i += 1) {\r\n      const midiValue = getMidiValueFromNoteName(midiNoteNameSequence[i]);\r\n      if (midiValue < firstKeyRangeMidiValue) {\r\n        firstKeyRangeMidiValue = midiValue;\r\n      }\r\n      if (midiValue > lastKeyRangeMidiValue) {\r\n        lastKeyRangeMidiValue = midiValue;\r\n      }\r\n    }\r\n  } else {\r\n    for (const vector of vectors) {\r\n      if (firstKeyRangeMidiValue > lastKeyRangeMidiValue - vector) {\r\n        firstKeyRangeMidiValue = lastKeyRangeMidiValue - vector;\r\n      }\r\n      if (lastKeyRangeMidiValue < firstKeyRangeMidiValue + vector) {\r\n        lastKeyRangeMidiValue = firstKeyRangeMidiValue + vector;\r\n      }\r\n    }\r\n  }\r\n  return [firstKeyRangeMidiValue, lastKeyRangeMidiValue];\r\n};\r\n\r\nexport const shiftKeyRangeIfNeeded = (firstMidiVal, lastMidiVal) => {\r\n  let firstKeyRangeMidiValue = firstMidiVal;\r\n  let lastKeyRangeMidiValue = lastMidiVal;\r\n  const width = lastKeyRangeMidiValue - firstKeyRangeMidiValue;\r\n\r\n  // Since widenKeyRangeIfNeeded always adds keys below, only upwards shift is needed\r\n  if (firstKeyRangeMidiValue < 21) {\r\n    firstKeyRangeMidiValue = 21;\r\n    lastKeyRangeMidiValue = width + 21;\r\n  }\r\n  return [firstKeyRangeMidiValue, lastKeyRangeMidiValue];\r\n};\r\n\r\nexport const ensureOneInversionIsChecked = (index, newTests) => {\r\n  let areAllInversionsUnchecked = true;\r\n  for (const key of Object.keys(newTests[index].inversionCheckboxStates)) {\r\n    if (newTests[index].inversionCheckboxStates[key]) {\r\n      areAllInversionsUnchecked = false;\r\n    }\r\n  }\r\n  if (areAllInversionsUnchecked) {\r\n    newTests[index].inversionCheckboxStates[INVERSIONS.fundamental] = true;\r\n  }\r\n};\r\n\r\nexport const ensureOneChordIsChecked = (index, newTests) => {\r\n  let areAllChordsUnchecked = true;\r\n  for (const key of Object.keys(newTests[index].triadCheckboxStates)) {\r\n    if (newTests[index].triadCheckboxStates[key]) {\r\n      areAllChordsUnchecked = false;\r\n    }\r\n  }\r\n  for (const key of Object.keys(newTests[index].seventhChordCheckboxStates)) {\r\n    if (newTests[index].seventhChordCheckboxStates[key]) {\r\n      areAllChordsUnchecked = false;\r\n    }\r\n  }\r\n  if (areAllChordsUnchecked) {\r\n    newTests[index].triadCheckboxStates[TRIADS.majorTriad] = true;\r\n  }\r\n};\r\n\r\nexport const ensureOneIntervalIsChecked = (index, newTests, exerciseType) => {\r\n  let areAllIntervalsUnchecked = true;\r\n  for (const key of Object.keys(newTests[index][`${exerciseType}CheckboxStates`])) {\r\n    if (typeof newTests[index][`${exerciseType}CheckboxStates`][key].minor === 'undefined') {\r\n      if (newTests[index][`${exerciseType}CheckboxStates`][key]) {\r\n        areAllIntervalsUnchecked = false;\r\n      }\r\n    } else if (typeof newTests[index][`${exerciseType}CheckboxStates`][key].minor !== 'undefined') {\r\n      if (newTests[index][`${exerciseType}CheckboxStates`][key].minor || newTests[index][`${exerciseType}CheckboxStates`][key].major) {\r\n        areAllIntervalsUnchecked = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (areAllIntervalsUnchecked) {\r\n    newTests[index][`${exerciseType}CheckboxStates`].second.minor = true;\r\n    newTests[index][`${exerciseType}CheckboxStates`].second.major = true;\r\n  }\r\n};\r\n\r\nexport const getNumberOfAbcNotes = string => {\r\n  let numberOfAbcNotes = 0;\r\n  const validNoteNameChars = ['c', 'd', 'e', 'f', 'g', 'a', 'b', 'C', 'D', 'E', 'F', 'G', 'A', 'B'];\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    if (validNoteNameChars.includes(string[i])) {\r\n      numberOfAbcNotes += 1;\r\n    }\r\n  }\r\n  return numberOfAbcNotes;\r\n};\r\n"],
  "mappings": "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",
  "names": ["abcNoteName", "midiNoteName", "midiValue"]
}
